# -*- coding: utf-8 -*-
"""analyze_ss_movingload.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q9eRKYerEdwkdGAL_sqle4ZdcLVv-6Mu
"""

def analyze_beam(L, W1, W2, x):
    """
    Analyze a simply supported beam with two moving loads.

    :param L: Length of the beam in meters
    :param W1: Magnitude of the first moving load in kN
    :param W2: Magnitude of the second moving load in kN
    :param x: Distance between the two loads in meters

    :return: Dictionary containing:
        - Maximum Reaction at A (kN)
        - Maximum Reaction at B (kN)
        - Bending Moment BM_01 (kNm)
        - Shear Force SF_01 (kN)
        - Maximum Shear Force SF_max (kN)
        - Location of SF_max (m)
        - Maximum Bending Moment BM_max (kNm)
        - Location of BM_max (m)
    """

    # caluclating the maximum reactions at A and b
    RA_max = (W1 * L + W2 * (L - x)) / L
    RB_max = (W1 * (L - x) + W2 * L) / L

    # The value of Bending Moment BM_01 when W1 is at 0 m (it is always zero at the support conditions)
    BM_01 = 0.0

    # Shear Force SF_01 at 0.5L using influence line
    mid_L = 0.5 * L
    # Position of W2 load when W1 is at the mid point of the beam length
    W2_pos = mid_L + x
    if W2_pos > L:
        IL_W2 = 0.0
    else:
        IL_W2 = (L - W2_pos) / L
        IL_W2 = max(IL_W2, 0.0)  # Influence line can't be negative
    SF_01 = W1 * 0.5 + W2 * IL_W2

    #The value of  Maximum Shear Force with its location
    SF_max = max(RA_max, RB_max)
    y_location = 0.0 if RA_max > RB_max else L

    # Maximum Bending Moment and its location using influence line approach
    # Calculate optimal position z1 for maximum BM
    if (W1 + W2) == 0:
        BM_max = 0.0
        z_location = 0.0
    else:
        z1_numerator = W1 * L + W2 * (L - 2 * x)
        z1_denominator = 2 * (W1 + W2)
        z1 = z1_numerator / z1_denominator

        # Ensuring that the  z1 is within valid range [0, L - x]
        z1 = max(z1, 0.0)
        z1 = min(z1, L - x)

        # Calculating the  BM at the optimal position
        a = z1
        R_A = (W1 * (L - a) + W2 * (L - a - x)) / L
        BM_under_W1 = R_A * a
        BM_under_W2 = R_A * (a + x) - W1 * x

        # Determine which BM is larger
        if BM_under_W1 >= BM_under_W2:
            BM_max = BM_under_W1
            z_location = a
        else:
            BM_max = BM_under_W2
            z_location = a + x

    # Returning the results as a dictionary
    return {
        "Maximum Reaction at A (kN)": round(RA_max, 2),
        "Maximum Reaction at B (kN)": round(RB_max, 2),
        "Bending Moment BM_01 (kNm)": round(BM_01, 2),
        "Shear Force SF_01 (kN)": round(SF_01, 2),
        "Maximum Shear Force SF_max (kN)": round(SF_max, 2),
        "Location of SF_max (m)": round(y_location, 2),
        "Maximum Bending Moment BM_max (kNm)": round(BM_max, 2),
        "Location of BM_max (m)": round(z_location, 2)
    }

# taking the inputs from the user
L = float(input("Enter length of the beam (L in meters): "))
W1 = float(input("Enter magnitude of first load W1 (in kN): "))
W2 = float(input("Enter magnitude of second load W2 (in kN): "))
x = float(input("Enter distance between the loads (x in meters): "))

# calling the function
result = analyze_beam(L, W1, W2, x)

# printing the result line by line
print("\nBeam Analysis Results")
for key, value in result.items():
    print(f"{key}: {value}")

